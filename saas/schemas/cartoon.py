"""
Pydantic models for the Cartoon Generation Engine.
Defines the data structures for script, scenes, and generation requests.

Author: Herbbie Team
Version: 1.0.0
"""

from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from enum import Enum
from datetime import datetime


class AspectRatio(str, Enum):
    """Aspect ratios supported by Wan 2.5."""
    VERTICAL = "9:16"       # TikTok/Reels style (default for Herbbie)
    HORIZONTAL = "16:9"     # YouTube/Traditional
    SQUARE = "1:1"          # Instagram


class Resolution(str, Enum):
    """Video resolutions supported by WaveSpeed Wan 2.5."""
    SD = "480p"
    HD = "720p"
    FULL_HD = "1080p"


class GenerationStatus(str, Enum):
    """Status of a generation task."""
    PENDING = "pending"
    MODERATING = "moderating"
    GENERATING_SCRIPT = "generating_script"
    GENERATING_CLIPS = "generating_clips"
    STITCHING = "stitching"
    COMPLETED = "completed"
    FAILED = "failed"
    PARTIAL_SUCCESS = "partial_success"  # Some clips failed but others succeeded


class CharacterSheet(BaseModel):
    """
    Character Sheet for consistent character appearance across scenes.
    This is the "Series Bible" approach from the prompt.md.
    """
    name: str = Field(..., description="Character name (e.g., 'Luna the Fox')")
    visual_description: str = Field(
        ..., 
        description="Precise visual description for consistency (e.g., 'A chubby orange fox with a blue backpack')"
    )
    personality_traits: List[str] = Field(
        default_factory=list,
        description="Personality traits that affect animation (e.g., ['curious', 'playful', 'brave'])"
    )
    color_palette: Optional[List[str]] = Field(
        default=None,
        description="Main colors associated with this character"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Luna the Fox",
                "visual_description": "A chubby orange fox with bright amber eyes, wearing a small blue backpack with golden stars",
                "personality_traits": ["curious", "playful", "brave"],
                "color_palette": ["#FF6B35", "#1E90FF", "#FFD700"]
            }
        }


class Scene(BaseModel):
    """
    A single scene in the animation.
    Each scene represents a 5-second video clip generated by Wan 2.5.
    """
    scene_number: int = Field(..., ge=1, description="Scene order (1-indexed)")
    prompt: str = Field(..., description="The video generation prompt for this scene")
    visual_description: str = Field(..., description="What happens visually in this scene")
    camera_angle: str = Field(
        default="medium shot",
        description="Camera angle/framing (e.g., 'close-up', 'wide shot', 'aerial view')"
    )
    audio_description: str = Field(
        default="",
        description="Description of audio/soundtrack for this scene"
    )
    duration_seconds: int = Field(default=5, ge=3, le=10, description="Clip duration (5s default for Wan 2.5)")
    
    # Generation results
    video_url: Optional[str] = Field(default=None, description="URL of generated video clip")
    status: GenerationStatus = Field(default=GenerationStatus.PENDING)
    error_message: Optional[str] = Field(default=None, description="Error message if generation failed")
    retry_count: int = Field(default=0, description="Number of retry attempts")

    def build_wan_prompt(self, character_sheet: Optional[CharacterSheet] = None) -> str:
        """
        Build the complete prompt for Wan 2.5 API.
        Format: {Visual_Description} + {Character_Sheet} + {Camera_Angle}. Soundtrack: {Audio_Description}
        """
        parts = [self.visual_description]
        
        if character_sheet:
            parts.append(f"Main character: {character_sheet.visual_description}")
        
        parts.append(f"Camera: {self.camera_angle}")
        
        if self.audio_description:
            parts.append(f"Soundtrack: {self.audio_description}")
        
        return ". ".join(parts)


class Script(BaseModel):
    """
    Complete script for the animation (Series Bible).
    Contains the overall story structure and all scenes.
    """
    title: str = Field(..., description="Animation title")
    theme: str = Field(..., description="User-provided theme")
    synopsis: str = Field(..., description="Brief story synopsis")
    target_duration_seconds: int = Field(..., ge=5, le=300, description="Total target duration")
    
    # Character consistency
    main_character: Optional[CharacterSheet] = Field(default=None, description="Main character sheet")
    supporting_characters: List[CharacterSheet] = Field(default_factory=list)
    
    # Story elements
    setting: str = Field(..., description="Environment/setting description")
    mood: str = Field(default="joyful", description="Overall mood (joyful, adventurous, calm, etc.)")
    
    # Scenes
    scenes: List[Scene] = Field(default_factory=list, description="List of scenes")
    
    # Generation metadata
    num_scenes: int = Field(default=0, description="Calculated number of scenes")
    actual_duration_seconds: int = Field(default=0, description="Actual total duration")

    @validator('num_scenes', always=True)
    def calculate_num_scenes(cls, v, values):
        """Calculate number of scenes based on target duration (5s per clip)."""
        target = values.get('target_duration_seconds', 30)
        return max(1, target // 5)

    @validator('actual_duration_seconds', always=True)
    def calculate_actual_duration(cls, v, values):
        """Calculate actual duration from scenes."""
        scenes = values.get('scenes', [])
        if scenes:
            return sum(s.duration_seconds for s in scenes)
        return values.get('num_scenes', 1) * 5


class GenerationRequest(BaseModel):
    """
    User request for animation generation.
    Input to the WanVideoOrchestrator.run_pipeline() method.
    """
    user_id: str = Field(..., description="Supabase user ID")
    theme: str = Field(..., min_length=2, max_length=200, description="Animation theme")
    duration_seconds: int = Field(
        default=30, 
        ge=5, 
        le=120,  # Max 2 minutes for now
        description="Target duration in seconds"
    )
    style: str = Field(
        default="cartoon",
        description="Visual style (cartoon, anime, 3d, realistic)"
    )
    custom_prompt: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Optional custom instructions"
    )
    aspect_ratio: AspectRatio = Field(
        default=AspectRatio.VERTICAL,
        description="Video aspect ratio"
    )
    resolution: Resolution = Field(
        default=Resolution.HD,
        description="Video resolution"
    )
    
    # Advanced options
    character_name: Optional[str] = Field(
        default=None,
        description="Optional: Name for the main character"
    )
    setting_preference: Optional[str] = Field(
        default=None,
        description="Optional: Preferred setting/environment"
    )

    @validator('theme')
    def sanitize_theme(cls, v):
        """Basic sanitization of theme input."""
        # Remove potentially problematic characters
        return v.strip().replace('<', '').replace('>', '').replace('"', "'")

    class Config:
        json_schema_extra = {
            "example": {
                "user_id": "uuid-123-456",
                "theme": "A magical forest adventure",
                "duration_seconds": 30,
                "style": "cartoon",
                "aspect_ratio": "9:16",
                "resolution": "720p"
            }
        }


class GenerationResult(BaseModel):
    """
    Result of a complete animation generation.
    Returned by WanVideoOrchestrator.run_pipeline().
    """
    task_id: str = Field(..., description="Unique task identifier")
    user_id: str = Field(..., description="User who requested the generation")
    status: GenerationStatus = Field(..., description="Final status")
    
    # Output
    final_video_url: Optional[str] = Field(default=None, description="URL of final stitched video")
    video_urls: List[str] = Field(default_factory=list, description="Individual clip URLs")
    
    # Metadata
    script: Optional[Script] = Field(default=None, description="Generated script")
    title: str = Field(default="", description="Animation title")
    duration_seconds: int = Field(default=0, description="Actual duration")
    theme: str = Field(default="", description="Original theme")
    style: str = Field(default="cartoon", description="Visual style")
    
    # Statistics
    total_clips: int = Field(default=0)
    successful_clips: int = Field(default=0)
    failed_clips: int = Field(default=0)
    
    # Timing
    started_at: Optional[datetime] = Field(default=None)
    completed_at: Optional[datetime] = Field(default=None)
    generation_time_seconds: Optional[float] = Field(default=None)
    
    # Errors
    error_message: Optional[str] = Field(default=None)
    debug_prompts: Optional[List[str]] = Field(
        default=None,
        description="Store prompts for debugging"
    )

    def to_frontend_response(self) -> Dict[str, Any]:
        """Convert to frontend-friendly response format."""
        return {
            "task_id": self.task_id,
            "status": self.status.value,
            "final_video_url": self.final_video_url,
            "video_urls": self.video_urls,
            "title": self.title,
            "duration": self.duration_seconds,
            "theme": self.theme,
            "style": self.style,
            "clips": [
                {
                    "scene_number": i + 1,
                    "video_url": url,
                    "duration": 5,
                    "status": "success"
                }
                for i, url in enumerate(self.video_urls)
            ],
            "stats": {
                "total_clips": self.total_clips,
                "successful_clips": self.successful_clips,
                "failed_clips": self.failed_clips,
                "generation_time": self.generation_time_seconds
            },
            "generated_at": self.completed_at.isoformat() if self.completed_at else None
        }


class ProgressUpdate(BaseModel):
    """
    Progress update for real-time status updates.
    Used to update Supabase and frontend.
    """
    task_id: str
    status: GenerationStatus
    progress_percent: int = Field(ge=0, le=100)
    current_step: str = Field(default="", description="Description of current step")
    message: str = Field(default="")
    
    # Optional detailed progress
    clips_completed: int = Field(default=0)
    clips_total: int = Field(default=0)
    estimated_remaining_seconds: Optional[int] = Field(default=None)

